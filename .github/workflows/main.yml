name: Deploy to DigitalOcean Droplet

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: |
          cd backend
          npm ci --legacy-peer-deps
          cd ../
          npm ci --legacy-peer-deps

  build-and-deploy:
    name: Build and Deploy
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Build and export backend
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile.backend
          tags: ihsan/backend:latest
          outputs: type=docker,dest=/tmp/backend.tar
      
      - name: Build and export frontend
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile.frontend
          tags: ihsan/frontend:latest
          outputs: type=docker,dest=/tmp/frontend.tar
      
      # Create required deployment files
      - name: Create deployment files
        run: |
          # Create docker-compose.prod.yml
          echo 'version: "3.8"

          services:
            frontend:
              image: ihsan/frontend:latest
              restart: always
              ports:
                - "8080:80"
              environment:
                - VITE_API_URL=/api

            backend:
              image: ihsan/backend:latest
              restart: always
              ports:
                - "3000:3000"
              environment:
                - NODE_ENV=production
                - JWT_SECRET=${JWT_SECRET}
                - DB_HOST=${DB_HOST:-postgres}
                - DB_PORT=${DB_PORT:-5432}
                - DB_USERNAME=${DB_USERNAME}
                - DB_PASSWORD=${DB_PASSWORD}
                - DB_DATABASE=${DB_DATABASE}
              depends_on:
                - postgres

            postgres:
              image: postgres:15-alpine
              restart: always
              volumes:
                - postgres_data:/var/lib/postgresql/data
              environment:
                - POSTGRES_PASSWORD=${DB_PASSWORD}
                - POSTGRES_USER=${DB_USERNAME}
                - POSTGRES_DB=${DB_DATABASE}
              ports:
                - "5432:5432"

            nginx:
              image: nginx:alpine
              restart: always
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./nginx-prod.conf:/etc/nginx/conf.d/default.conf
              depends_on:
                - frontend
                - backend

          volumes:
            postgres_data:' > docker-compose.prod.yml

          # Create nginx-prod.conf
          echo 'server {
              listen 80;
              
              location / {
                  proxy_pass http://frontend:80;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
              }
              
              location /api/ {
                  proxy_pass http://backend:3000/api/;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }' > nginx-prod.conf

          # Create .env.production
          echo 'JWT_SECRET=${{ secrets.JWT_SECRET }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          DB_HOST=postgres
          DB_PORT=5432' > .env.production

          # List files to debug
          ls -la
      
      - name: Upload deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USERNAME }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          source: "docker-compose.prod.yml,nginx-prod.conf,.env.production"
          target: "/opt/ihsan"
      
      - name: Upload Docker images
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USERNAME }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          source: "/tmp/backend.tar,/tmp/frontend.tar"
          target: "/tmp"
      
      - name: Deploy
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USERNAME }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            # Create directory if it doesn't exist
            mkdir -p /opt/ihsan
            
            # Load Docker images
            docker load -i /tmp/backend.tar
            docker load -i /tmp/frontend.tar
            
            # Navigate to app directory
            cd /opt/ihsan
            
            # Stop existing containers
            docker-compose -f docker-compose.prod.yml down || true
            
            # Start new containers
            docker-compose -f docker-compose.prod.yml up -d
            
            # Clean up temporary files
            rm -f /tmp/backend.tar /tmp/frontend.tar
